<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>自転車安全マップ</title>
    
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#ffffff">

    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    
    <style>
        body { margin: 0; font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, 'Open Sans', 'Helvetica Neue', sans-serif; display: flex; flex-direction: column; height: 100vh; }
        #map { flex-grow: 1; /* 地図が残りの高さをすべて使うようにする */ }
        #controls { padding: 10px; text-align: center; background: #f8f8f8; border-bottom: 1px solid #ddd; flex-shrink: 0; }
        #results { padding: 15px; font-size: 1.1em; text-align: center; background: #f8f8f8; border-top: 1px solid #ddd; flex-shrink: 0;}
        button { 
            font-size: 1.2em; /* 文字を大きく */
            padding: 15px 0; /* 上下のパディングを増やす */
            width: 45%; /* 幅を画面の45%に */
            margin: 5px 2%; 
            border: 1px solid #ccc;
            border-radius: 8px;
            background-color: #fff;
            cursor: pointer;
        }
        button:disabled {
            background-color: #e9e9e9;
            color: #999;
        }
    </style>
</head>
<body>

    <div id="controls">
        <button id="startBtn">走行開始</button>
        <button id="endBtn" disabled>走行終了</button>
    </div>
    <div id="results">「走行開始」ボタンを押してください</div>
    <div id="map"></div>

    <script>
        // --- 1. 初期設定 ---
        const map = L.map('map').setView([35.68, 139.76], 13);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors'
        }).addTo(map);

        const startBtn = document.getElementById('startBtn');
        const endBtn = document.getElementById('endBtn');
        const resultsDiv = document.getElementById('results');

        let isTracking = false;
        let watchId = null;
        let userTrack = []; // ユーザーの走行経路を保存する配列
        let userPolyline = null;
        let userMarker = null;

        // --- 2. UIのイベント設定 ---
        startBtn.addEventListener('click', startTracking);
        endBtn.addEventListener('click', endTracking);

        function startTracking() {
            isTracking = true;
            userTrack = [];
            startBtn.disabled = true;
            endBtn.disabled = false;
            resultsDiv.innerHTML = "走行を開始しました。<br>現在地を取得中です...";
            
            if (userPolyline) {
                userPolyline.remove();
            }

            watchId = navigator.geolocation.watchPosition(
                (position) => {
                    const latlng = [position.coords.latitude, position.coords.longitude];
                    userTrack.push(latlng);
                    
                    if (!userMarker) {
                        userMarker = L.marker(latlng).addTo(map);
                    } else {
                        userMarker.setLatLng(latlng);
                    }
                    map.setView(latlng, 17);

                    if (userTrack.length > 1) {
                        userPolyline = L.polyline(userTrack, { color: 'blue' }).addTo(map);
                    }
                    resultsDiv.textContent = `走行中... (記録地点: ${userTrack.length}件)`;
                },
                (error) => { 
                    console.error(error); 
                    resultsDiv.textContent = "エラー: 位置情報を取得できません。"; 
                },
                { enableHighAccuracy: true }
            );
        }

        async function endTracking() {
            if (!isTracking) return;
            navigator.geolocation.clearWatch(watchId);
            isTracking = false;
            startBtn.disabled = false;
            endBtn.disabled = true;
            resultsDiv.textContent = "走行終了。経路を解析中です...";
            
            if (userTrack.length < 2) {
                resultsDiv.textContent = "走行データが短すぎます。";
                return;
            }

            await analyzeTrack(userTrack);
        }

        async function analyzeTrack(track) {
            const bounds = L.latLngBounds(track);
            const bbox = `${bounds.getSouth()},${bounds.getWest()},${bounds.getNorth()},${bounds.getEast()}`;
            const query = `
                [out:json][timeout:25];
                (
                    way["highway"](bbox);
                    way["footway"="sidewalk"](bbox);
                );
                out geom;`;
            
            try {
                const response = await fetch('https://overpass-api.de/api/interpreter', {
                    method: 'POST',
                    body: "data=" + encodeURIComponent(query)
                });
                if (!response.ok) throw new Error(`Overpass APIエラー: ${response.status}`);
                const osmData = await response.json();

                let roadwayDist = 0;
                let sidewalkDist = 0;

                for (let i = 0; i < track.length - 1; i++) {
                    const segmentStart = L.latLng(track[i]);
                    const segmentEnd = L.latLng(track[i+1]);
                    const segmentMidpoint = L.latLng(
                        (segmentStart.lat + segmentEnd.lat) / 2,
                        (segmentStart.lng + segmentEnd.lng) / 2
                    );
                    const segmentDist = segmentStart.distanceTo(segmentEnd);

                    let nearestWay = findNearestWay(segmentMidpoint, osmData.elements);

                    if (nearestWay && nearestWay.tags.footway === 'sidewalk') {
                        sidewalkDist += segmentDist;
                    } else { 
                        roadwayDist += segmentDist;
                    }
                }

                const totalDist = roadwayDist + sidewalkDist;
                const roadwayRatio = totalDist > 0 ? (roadwayDist / totalDist * 100).toFixed(1) : 0;
                
                resultsDiv.innerHTML = `
                    <strong>分析結果</strong><br>
                    総走行距離: ${totalDist.toFixed(0)}m<br>
                    車道走行の割合: <strong>${roadwayRatio}%</strong>
                `;
            } catch (error) {
                console.error("解析エラー:", error);
                resultsDiv.textContent = "経路の解析に失敗しました。";
            }
        }

        function findNearestWay(point, ways) {
            let minDistance = Infinity;
            let closestWay = null;
            ways.forEach(way => {
                if (way.type === 'way' && way.geometry) {
                    for (let i = 0; i < way.geometry.length -1; i++){
                        const node1 = L.latLng(way.geometry[i].lat, way.geometry[i].lon);
                        const node2 = L.latLng(way.geometry[i+1].lat, way.geometry[i+1].lon);
                        
                        const distance = L.GeometryUtil.distance(map, point, node1, node2);

                        if (distance < minDistance) {
                            minDistance = distance;
                            closestWay = way;
                        }
                    }
                }
            });
            return closestWay;
        }

        // 初期メッセージ
        resultsDiv.textContent = "「走行開始」ボタンを押して計測を開始してください。";
    </script>
</body>
</html>